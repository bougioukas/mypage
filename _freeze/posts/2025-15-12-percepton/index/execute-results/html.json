{
  "hash": "dea829d4c23c1bc83ab726cd610d9b46",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Perceptron: the first artificial neuron\"\ndescription: \"The perceptron is one of the earliest and simplest models of an artificial neuron, introduced first by Warren McCulloch and Walter Pitts in 1943, and later by Frank Rosenblatt in 1958, as a computational approach inspired by biological neurons.\"\nauthor: \n    - name: Konstantinos Bougioukas \ndate: \"2026-01-03\"\ncategories: [Statistics]\nimage: \"perceptron.png\"\ncss: /custom.css\n#draft: true\n---\n\n\n\n​\n\n## The perceptron\n\nThe perceptron is one of the earliest and simplest models of an artificial neural network [@McCulloch1943; @ROSENBLATT1958]. Conceptually, it corresponds to a single artificial neuron that makes binary decisions. Despite its simplicity, the perceptron introduced the core ideas of weighted inputs, linear decision boundaries, and supervised learning for classification tasks—ideas that remain central to modern deep learning.\n\nAt its heart, the perceptron learns to separate data into two classes by finding a linear boundary that divides the input space. Each prediction is obtained by combining the inputs linearly and passing the result through a threshold function that produces a discrete output.\n\n\n\n### How it works\n\nThe *Perceptron* can be viewed as a simple directed graph, with edges connecting each input to the output and parameterized by weights. The output of the perceptron depends both on the values of the input nodes and on the weights associated with the incoming edges, which control how strongly each input influences the final decision.\n\n\n![Schematic of a simple Perceptron model.](perceptron.png){width=50%}\n\n​\n\n\n### Basic set up and notation\n\nThe *Perceptron* takes multiple input features, multiplies each by an associated weight, sums these weighted inputs along with a bias term, and then applies a threshold decision (activation) function to determine the output class. This process can be described compactly using vector notation.\n\nSuppose our dataset consists of $P$ input-target pairs \n\n$$(\\mathbf{x_1}, y_1), (\\mathbf{x_2}, y_2), ..., (\\mathbf{x_P}, y_P)$$ \n\nor equivalently, \n\n\n$$\\left\\{ \\left(\\mathbf{x}_{p},y_{p}\\right)\\right\\} _{p=1}^{P}$$\n\nwhere $\\mathbf{x_p}$ denotes the input feature vector for the $p-$observation and $y_p \\in \\{-1, +1\\}$ represents the corresponding binary target label.\n\nEach input $\\mathbf{x_p}$ is a column vector of length $N + 1$, where the leading component is fixed to 1 in order to incorporate the bias term directly into the model: \n\n$$\\mathbf{x_p} = \\begin{bmatrix} 1 \\\\ x_{1,\\ p} \\\\ x_{2,\\ p} \\\\\\vdots \\\\ x_{N,\\ P} \\end{bmatrix}$$\n\nThe model parameters—the bias and feature weights—are collected into a single column vector:\n\n$$\\mathbf{w} = \\begin{bmatrix} w_0 \\\\ w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_N \\end{bmatrix}$$\n\n\nThe target labels are represented by a vector $\\mathbf{y}$ of length $P$ : \n\n$$\\mathbf{y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_P \\end{bmatrix}$$\n\n\n### Linear Combination\n\nFor a single observation $p$, the perceptron computes a net input $z_p$ by taking the dot product of the weight vector and the input vector:\n\n\n$$z_p = \\mathbf{w}^{\\mathsf{T}}\\mathbf{x}_p$$\n\nwhere the superscript $\\mathsf{T}$ denotes transposition.\n\n\nExpanding this expression makes the computation explicit:\n\n$$\\begin{aligned}\nz_p &= \\begin{bmatrix} w_0 & w_1 & \\cdots & w_N \\end{bmatrix} \\begin{bmatrix} 1 \\\\ x_{1,\\ p} \\\\ x_{2,\\ p} \\\\\\vdots \\\\ x_{N,\\ P} \\end{bmatrix} \\\\\n&= (w_0 \\cdot 1) + (w_1 \\cdot x_{1,p}) + \\dots + (w_N \\cdot x_{N,P})  \\\\\n&= \\underbrace{\\enspace w_0 \\enspace}_{\\text{bias}} + \\underbrace{\\sum_{n=1}^{N} w_{n} \\cdot x_{n, p}}_{\\text{sum of weights}}\n\\end{aligned}$$\n\n\nThus, the net input is simply a **weighted sum** of the input features plus a bias term.\n\n\n​\n\n\n### Activation function and decision boundary\n\nIn the classic perceptron, the **activation function** $f(\\cdot)$ is a step function, which maps the continuous net input to one of two discrete class labels. One possible choice is the **sign function**, which assigns a label depending on whether the net input is non-negative or negative, as follows:\n\n​\n\n$$\\hat y_p = \\text{sign}(z_p) = \\begin{cases} 1 & \\text{if } z_p \\ge 0 \\\\ -1 & \\text{if } z_p < 0 \\end{cases}$$\n\n​\n\nThrough this simple rule, the perceptron partitions the input space into two regions separated by a linear **decision boundary**, classifying inputs on one side as $+1$ and those on the other side as $-1$, which is why it is considered a linear binary classifier; this decision boundary is defined as the input vectors for which the net input is zero, that is, $\\mathbf{w}^{\\mathsf{T}}\\mathbf{x}_p = 0$.\n\n​\n\n### The weight update rule\n\nThe perceptron learning rule is an example of supervised training. For each input, the network produces an output ($\\hat y_p$), which is compared to the target value $y$. The learning rule then updates the network’s weights of the network in order to move the network output closer to the target.\n\nLet $\\mathbf{w}^{\\text{old}}$ denote the weight vector before the update, and $\\mathbf{w}^{\\text{new}}$ denote the weight vector after the update. The learning rule is expressed as:\n\n$$\\mathbf{w}^{\\text{new}} = \\mathbf{w}^{\\text{old}} + \\eta \\, (y_p - \\hat{y}_p) \\, \\mathbf{x}_p$$\n\nwhere $\\eta > 0$ is the learning rate, controlling the step size of each update. The error term $(y_p - \\hat{y}_p)$ is a discrete scalar that determines the nature of the weight update.\n\nThe perceptron learning rule adjusts the weight vector in the direction that reduces the error for the specific example $p$:\n\n- **Correct prediction** ($y_p = \\hat{y}_p$): Since $(y_p - \\hat{y}_p) = 0$, the update term is zero. No change is made, as the model’s current boundary already correctly classifies the point.\n\n- **Incorrect prediction** ($y_p \\neq \\hat{y}_p$): The term $(y_p - \\hat{y}_p)$ becomes either $+2$ or $-2$. The weights are \"nudged\" in the direction of $y_p \\mathbf{x}_p$, moving the decision boundary.\n\n​\n\n### Convergence and separability\n\nTraining begins by assigning initial values to the network parameters. The perceptron learns by iteratively adjusting its weights to minimize classification errors. Learning proceeds in **epochs**, with each epoch representing a complete pass through the training dataset. During an epoch, the order of training examples may be randomly shuffled to improve generalization and prevent bias from the data sequence. Because weight updates are made incrementally after each individual example, multiple epochs are typically required for the decision boundary to gradually adjust and better separate the data. Whether this process eventually halts—achieving convergence—depends entirely on the linear separability of the training set.\n\nWhen the classes are **linearly separable**, meaning they can be perfectly divided by a straight line in two dimensions or a hyperplane in higher dimensions, the Perceptron Convergence Theorem guarantees that the algorithm will reach a finite weight vector that correctly classifies all training examples. At this point, the weights stabilize and no further updates occur. Conversely, if the data are not linearly separable, no such solution exists. The perceptron will continue updating its weights indefinitely, repeatedly shifting the decision boundary in an attempt to correct misclassifications. Fixing one misclassified point may cause another to become misclassified, producing oscillatory or “jittering” behavior. In practice, training on **non-separable** data is terminated after a fixed number of epochs to prevent unbounded computation.\n\n::: {layout-ncol=2}\n![Linearly separable dataset.](separated.png)\n\n![Non-separable dataset by a linear boundary.](notseparated.png)\n:::\n\n\n​\n\n## Perceptron example with R\n\n\n### Data Preparation\n\n**Dataset**\n\nFor this example, we’ll work with the well-known Iris dataset, one of the most commonly used datasets in machine learning. To simplify the task into a binary classification problem, we’ll focus on just two species: Iris versicolor and Iris virginica. Using the measurements of sepal length and petal length, we’ll explore how these features can be used to distinguish between the two species.\n\n![Sepal and peta lengths of iris dataset.](iris.png){width=70%}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the packages \nlibrary(tidyverse)\nlibrary(gganimate)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the dataset\ndata(iris)\ndf <- iris[iris$Species != \"setosa\", ] \ndf$y <- ifelse(df$Species == \"versicolor\", 1, -1)\n```\n:::\n\n\n\n​\n\n**Feature Scaling**\n\nStandardization ensures all features have mean = 0 and standard deviation = 1. This helps the Perceptron converge faster and prevents features with larger scales from dominating the learning process.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Feature Scaling\ndf_scaled <- df\ndf_scaled[, 1:4] <- scale(df[, 1:4])\ndf_scaled_final <- df_scaled[, c(\"Sepal.Length\", \"Petal.Length\", \"y\")]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initial setup\nX <- as.matrix(df_scaled_final[, 1:2])\nX_augmented <- cbind(1, X) # leading 1 for bias\ny_vector <- df_scaled_final$y\n```\n:::\n\n\n\nThe augmented matrix includes a column of 1s, which allows us to incorporate the bias term $w_o$ directly into the weight vector.\n\n\n​\n\n### Implement the Perceptron Algorithm\n\n**Sign Activation Function**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsign_func <- function(z) {\n  ifelse(z >= 0, 1, -1)\n}\n```\n:::\n\n\n\n​\n\n**Perceptron Training Function**\n\nThe perceptron algorithm repeatedly cycles through training examples in a randomized order, iteratively adjusting weights only when a misclassification occurs. This process continues until the model achieves convergence (zero errors) or reaches a preset maximum number of epochs. Because the updates are incremental, a single data point may be processed multiple times across different epochs, gradually nudging the decision boundary until it successfully partitions the classes with a valid separating hyperplane.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_perceptron <- function(X_aug, y, eta = 0.05, n_iter = 10) {\n  n_features <- ncol(X_aug)\n  n_obs <- nrow(X_aug)\n  \n  # Initialize weights\n  set.seed(842)\n  w <- rnorm(n_features, mean = 0, sd = 0.1) \n  \n  history_list <- list()\n  epoch_errors <- numeric(n_iter)\n  step_total <- 0\n  \n  for (epoch in 1:n_iter) {\n    # --- Shuffle data at the start of every epoch ---\n    indices <- sample(n_obs)\n    X_shuffled <- X_aug[indices, ]\n    y_shuffled <- y[indices]\n    \n    error_count <- 0\n    \n    for (p in 1:n_obs) {\n      step_total <- step_total + 1\n      x_p <- X_shuffled[p, ]\n      y_p <- y_shuffled[p]\n      \n      # Linear Combination\n      z_p <- as.numeric(t(w) %*% x_p)\n      y_hat <- sign_func(z_p)\n      \n      is_error <- (y_hat != y_p)\n      if (is_error) {\n        # Perceptron Update Rule\n        w <- w + eta * (y_p - y_hat) * x_p\n        error_count <- error_count + 1\n      }\n      \n      # Calculate accuracy on full dataset for tracking\n      predictions <- sign_func(X_aug %*% w)\n      current_accuracy <- sum(predictions == y) / length(y) * 100\n      \n      # Record history\n      history_list[[step_total]] <- data.frame(\n        Step = step_total, \n        Epoch = epoch,\n        Iteration = p,\n        w0 = w[1], w1 = w[2], w2 = w[3],\n        x1_val = x_p[2], x2_val = x_p[3], # Tracks the specific point being tested\n        is_error = is_error,\n        current_acc = current_accuracy\n      )\n    }\n    \n    epoch_errors[epoch] <- error_count\n    cat(sprintf(\"Epoch %d: %d errors\\n\", epoch, error_count))\n    \n    if (error_count == 0) {\n      cat(sprintf(\"--- Converged early at Epoch %d ---\\n\", epoch))\n      break\n    }\n  }\n  \n  return(list(\n    weights = w, \n    errors = epoch_errors[1:epoch], \n    history = bind_rows(history_list)\n  ))\n}\n```\n:::\n\n\n\n​\n\nLet’s train the perceptron model for 30 epochs and record how many times the weights are updated during each full pass through the training data in each Epoch (Epoch error).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Training\nresults <- fit_perceptron(X_augmented, y_vector, n_iter = 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEpoch 1: 14 errors\nEpoch 2: 12 errors\nEpoch 3: 8 errors\nEpoch 4: 11 errors\nEpoch 5: 13 errors\nEpoch 6: 9 errors\nEpoch 7: 8 errors\nEpoch 8: 7 errors\nEpoch 9: 3 errors\nEpoch 10: 8 errors\nEpoch 11: 10 errors\nEpoch 12: 8 errors\nEpoch 13: 7 errors\nEpoch 14: 6 errors\nEpoch 15: 10 errors\nEpoch 16: 9 errors\nEpoch 17: 10 errors\nEpoch 18: 8 errors\nEpoch 19: 6 errors\nEpoch 20: 4 errors\nEpoch 21: 7 errors\nEpoch 22: 9 errors\nEpoch 23: 9 errors\nEpoch 24: 7 errors\nEpoch 25: 8 errors\nEpoch 26: 5 errors\nEpoch 27: 8 errors\nEpoch 28: 11 errors\nEpoch 29: 7 errors\nEpoch 30: 5 errors\n```\n\n\n:::\n\n```{.r .cell-code}\nhistory_df <- results$history\nerrors <- results$errors\nw_final <- results$weights\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Epoch error plot\nplot(1:length(errors), errors, type = \"o\", pch = 16, \n     col = \"blue\", lwd = 2, cex = 1.5,\n     main = \"Learning Curve (30 epochs)\", xlab = \"Epoch\", ylab = \"Errors\")\n```\n\n::: {.cell-output-display}\n![Perceptron learning curve showing epoch error](index_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n\n\nThe algorithm is not converging - the errors are oscillating between 3 and 14, never reaching zero. Correcting one misclassification inevitably leads to another, causing a never-ending cycle of updates. This behavior indicates that the data are **not perfectly** linearly separable.\n\n\n​\n\n**Simulate the Learning Process**\n\nWe’ll simulate the training process and compute *current accuracy*, defined as the percentage of the **entire dataset** that is correctly classified by the weights at any given **moment**.\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](perceptron_learning.gif)\n:::\n:::\n\n\n\n\n​\n\nThe final decision boundary is the geometric representation of our learned classifier for the peak current accuracy.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Final decision boundary separating Versicolor and Virginica](index_files/figure-html/unnamed-chunk-11-1.png){width=768}\n:::\n:::\n\n\n\nWe observe 96% accuracy in Epoch 4, which means that at that specific point the model correctly classified 96 out of 100 points and only 4 points were misclassified (i.e., fell on the wrong side of the decision boundary).\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}